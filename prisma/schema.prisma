generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// Stores Discord users who have authenticated
model User {
  id        String   @id // Discord User ID
  roles     String[] // Discord role IDs
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  pendingSignatures PendingSignature[]
  economy           Economy?
}

// ===== $PEP ECONOMY SYSTEM =====

// User's $PEP balance - linked to User model
model Economy {
  id        String   @id // Discord User ID
  wallet    Int      @default(0)
  user      User     @relation(fields: [id], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Shop items available for purchase
model ShopItem {
  id          Int         @id @default(autoincrement())
  name        String      @unique
  description String?
  price       Int
  quantity    Int         @default(-1) // -1 = unlimited
  image       String?     // URL to item image
  isAvailable Boolean     @default(true)
  createdAt   DateTime    @default(now())
  inventory   Inventory[]
}

// User's inventory of purchased items
model Inventory {
  userId   String
  itemId   Int
  quantity Int      @default(1)
  item     ShopItem @relation(fields: [itemId], references: [id])

  @@id([userId, itemId])
}

// Jobs synced from Google Sheets
model Job {
  id          Int             @id @default(autoincrement())
  description String
  type        String?         // Category from spreadsheet
  sheetRow    Int?            // Row index for sync tracking
  isActive    Boolean         @default(true)
  createdAt   DateTime        @default(now())
  assignments JobAssignment[]
}

// Job assignments - who is working on what
model JobAssignment {
  id         Int      @id @default(autoincrement())
  jobId      Int
  userId     String
  assignedAt DateTime @default(now())
  job        Job      @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@unique([jobId, userId])
}

// Round-robin job cycle tracking
model JobCycle {
  id           Int @id @default(1)
  currentIndex Int @default(0)
}

// User-created bounties with escrowed rewards
model Bounty {
  id          Int              @id @default(autoincrement())
  description String
  link        String?          // Optional link for more details
  reward      Int              // Escrowed amount
  createdBy   String           // Discord ID of poster
  claimedBy   String?          // Discord ID of claimer
  status      BountyStatus     @default(OPEN)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  comments    BountyComment[]
}

// Comments/updates on bounties
model BountyComment {
  id        Int      @id @default(autoincrement())
  bountyId  Int
  authorId  String   // Discord ID of commenter
  content   String
  createdAt DateTime @default(now())
  bounty    Bounty   @relation(fields: [bountyId], references: [id], onDelete: Cascade)

  @@index([bountyId, createdAt])
}

enum BountyStatus {
  OPEN       // Available to claim
  CLAIMED    // Someone is working on it
  COMPLETED  // Work done, reward paid
  CANCELLED  // Poster cancelled, refunded
}

// Poll definition
model Poll {
  id              String   @id @default(cuid())
  question        String
  options         Json     // Array of { id: string, label: string }
  requiredRoleId  String   // Discord role ID required to vote
  status          PollStatus @default(DRAFT)
  createdBy       String   // Discord ID of creator
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  batchSignedAt   DateTime? // When tokens were generated

  results           PollResult[]
  pendingSignatures PendingSignature[]
}

enum PollStatus {
  DRAFT      // Created but not open
  OPEN       // Accepting votes
  CLOSED     // Voting ended, results visible
}

// Bridge table: stores signed tokens for eligible users
// This links identity to token temporarily, but the token itself
// is blinded so the server never sees the final voting credential
model PendingSignature {
  id         String @id @default(cuid())
  userId     String
  pollId     String
  blindedSig String // Base64 encoded blind signature

  user User @relation(fields: [userId], references: [id])
  poll Poll @relation(fields: [pollId], references: [id])

  @@unique([userId, pollId]) // One token per user per poll
}

// Anonymous vote tally - no link to user identity
model PollResult {
  pollId   String
  optionId String
  tally    Int    @default(0)

  poll Poll @relation(fields: [pollId], references: [id])

  @@id([pollId, optionId])
}

// Tracks consumed tokens to prevent double voting
// Only stores hash of token, not the token itself
model ConsumedToken {
  tokenHash String   @id
  pollId    String
  consumedAt DateTime @default(now())
}

// ===== TRANSACTION HISTORY =====

enum TransactionType {
  TRANSFER_SENT      // Sent $PEP to another user
  TRANSFER_RECEIVED  // Received $PEP from another user
  SHOP_PURCHASE      // Bought an item from the shop
  JOB_REWARD         // Earned $PEP from completing a job
  BOUNTY_ESCROW      // Escrowed $PEP when creating a bounty
  BOUNTY_REWARD      // Earned $PEP from completing a bounty
  BOUNTY_REFUND      // Refunded $PEP from cancelling a bounty
}

model Transaction {
  id          Int             @id @default(autoincrement())
  userId      String          // Discord ID of the user
  type        TransactionType
  amount      Int             // Signed: positive = credit, negative = debit
  balance     Int             // Running balance after this transaction
  description String          // Human-readable description
  metadata    Json?           // Optional extra data (bountyId, itemId, etc.)
  createdAt   DateTime        @default(now())

  @@index([userId, createdAt])
}

// ===== PROFILE LINKS =====

// User-added links on their profile (emoji + URL)
model ProfileLink {
  id        Int      @id @default(autoincrement())
  memberId  String   // Member ID from Google Sheets (not Discord ID)
  emoji     String   // Single emoji character
  url       String   // Full URL
  label     String?  // Optional display label
  sortOrder Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([memberId])
}

// ===== NOTIFICATION SYSTEM =====

enum NotificationType {
  BOUNTY_CLAIMED     // Someone claimed your bounty
  BOUNTY_COMPLETED   // Bounty you claimed is approved, reward paid
  BOUNTY_COMMENT     // New comment on a bounty you're involved in
  TASK_ASSIGNED      // A task was assigned to you
  TASK_DUE_SOON      // Task due within a week
  FRIEND_ADDED       // Someone started following you
}

model Notification {
  id          String           @id @default(cuid())
  type        NotificationType
  recipientId String           // Discord ID of notification recipient
  actorId     String?          // Discord ID of user who triggered it (optional)
  title       String           // Short title (e.g., "Bounty Claimed")
  message     String           // Detailed message
  metadata    Json?            // Type-specific data (bountyId, taskId, etc.)
  linkUrl     String?          // Optional deep link (e.g., /pep for bounty)
  createdAt   DateTime         @default(now())
  readAt      DateTime?        // Null = unread, timestamp = when read

  @@index([recipientId, createdAt])
  @@index([recipientId, readAt])
}

// ===== FRIENDS IN THE DAO =====

enum SocialPlatform {
  TWITTER
  FARCASTER
}

enum FriendSource {
  PIZZADAO
  TWITTER
  FARCASTER
}

// Social accounts linked to a member (X handle, Farcaster username)
model SocialAccount {
  id         Int            @id @default(autoincrement())
  memberId   String
  platform   SocialPlatform
  handle     String
  platformId String?
  verified   Boolean        @default(false)
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @updatedAt

  @@unique([memberId, platform])
  @@index([platform, handle])
  @@index([platform, platformId])
}

// One-way follow relationship between members
model Friendship {
  id         Int          @id @default(autoincrement())
  followerId String
  followeeId String
  source     FriendSource @default(PIZZADAO)
  createdAt  DateTime     @default(now())

  @@unique([followerId, followeeId])
  @@index([followerId])
  @@index([followeeId])
}
