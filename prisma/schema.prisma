generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// Stores Discord users who have authenticated
model User {
  id        String   @id // Discord User ID
  roles     String[] // Discord role IDs
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  pendingSignatures PendingSignature[]
  economy           Economy?
}

// ===== $PEP ECONOMY SYSTEM =====

// User's $PEP balance - linked to User model
model Economy {
  id        String   @id // Discord User ID
  wallet    Int      @default(0)
  user      User     @relation(fields: [id], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Shop items available for purchase
model ShopItem {
  id          Int         @id @default(autoincrement())
  name        String      @unique
  description String?
  price       Int
  quantity    Int         @default(-1) // -1 = unlimited
  image       String?     // URL to item image
  isAvailable Boolean     @default(true)
  createdAt   DateTime    @default(now())
  inventory   Inventory[]
}

// User's inventory of purchased items
model Inventory {
  userId   String
  itemId   Int
  quantity Int      @default(1)
  item     ShopItem @relation(fields: [itemId], references: [id])

  @@id([userId, itemId])
}

// Jobs synced from Google Sheets
model Job {
  id          Int             @id @default(autoincrement())
  description String
  type        String?         // Category from spreadsheet
  sheetRow    Int?            // Row index for sync tracking
  isActive    Boolean         @default(true)
  createdAt   DateTime        @default(now())
  assignments JobAssignment[]
}

// Job assignments - who is working on what
model JobAssignment {
  id         Int      @id @default(autoincrement())
  jobId      Int
  userId     String
  assignedAt DateTime @default(now())
  job        Job      @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@unique([jobId, userId])
}

// Round-robin job cycle tracking
model JobCycle {
  id           Int @id @default(1)
  currentIndex Int @default(0)
}

// User-created bounties with escrowed rewards
model Bounty {
  id          Int          @id @default(autoincrement())
  description String
  link        String?      // Optional link for more details
  reward      Int          // Escrowed amount
  createdBy   String       // Discord ID of poster
  claimedBy   String?      // Discord ID of claimer
  status      BountyStatus @default(OPEN)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
}

enum BountyStatus {
  OPEN       // Available to claim
  CLAIMED    // Someone is working on it
  COMPLETED  // Work done, reward paid
  CANCELLED  // Poster cancelled, refunded
}

// Poll definition
model Poll {
  id              String   @id @default(cuid())
  question        String
  options         Json     // Array of { id: string, label: string }
  requiredRoleId  String   // Discord role ID required to vote
  status          PollStatus @default(DRAFT)
  createdBy       String   // Discord ID of creator
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  batchSignedAt   DateTime? // When tokens were generated

  results           PollResult[]
  pendingSignatures PendingSignature[]
}

enum PollStatus {
  DRAFT      // Created but not open
  OPEN       // Accepting votes
  CLOSED     // Voting ended, results visible
}

// Bridge table: stores signed tokens for eligible users
// This links identity to token temporarily, but the token itself
// is blinded so the server never sees the final voting credential
model PendingSignature {
  id         String @id @default(cuid())
  userId     String
  pollId     String
  blindedSig String // Base64 encoded blind signature

  user User @relation(fields: [userId], references: [id])
  poll Poll @relation(fields: [pollId], references: [id])

  @@unique([userId, pollId]) // One token per user per poll
}

// Anonymous vote tally - no link to user identity
model PollResult {
  pollId   String
  optionId String
  tally    Int    @default(0)

  poll Poll @relation(fields: [pollId], references: [id])

  @@id([pollId, optionId])
}

// Tracks consumed tokens to prevent double voting
// Only stores hash of token, not the token itself
model ConsumedToken {
  tokenHash String   @id
  pollId    String
  consumedAt DateTime @default(now())
}

// ===== NOTIFICATION SYSTEM =====

enum NotificationType {
  BOUNTY_CLAIMED     // Someone claimed your bounty
  BOUNTY_COMPLETED   // Bounty you claimed is approved, reward paid
  TASK_ASSIGNED      // A task was assigned to you
  TASK_DUE_SOON      // Task due within a week
}

model Notification {
  id          String           @id @default(cuid())
  type        NotificationType
  recipientId String           // Discord ID of notification recipient
  actorId     String?          // Discord ID of user who triggered it (optional)
  title       String           // Short title (e.g., "Bounty Claimed")
  message     String           // Detailed message
  metadata    Json?            // Type-specific data (bountyId, taskId, etc.)
  linkUrl     String?          // Optional deep link (e.g., /pep for bounty)
  createdAt   DateTime         @default(now())
  readAt      DateTime?        // Null = unread, timestamp = when read

  @@index([recipientId, createdAt])
  @@index([recipientId, readAt])
}
