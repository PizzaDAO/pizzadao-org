generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// Stores Discord users who have authenticated
model User {
  id        String   @id // Discord User ID
  roles     String[] // Discord role IDs
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  pendingSignatures PendingSignature[]
}

// Poll definition
model Poll {
  id              String   @id @default(cuid())
  question        String
  options         Json     // Array of { id: string, label: string }
  requiredRoleId  String   // Discord role ID required to vote
  status          PollStatus @default(DRAFT)
  createdBy       String   // Discord ID of creator
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  batchSignedAt   DateTime? // When tokens were generated

  results           PollResult[]
  pendingSignatures PendingSignature[]
}

enum PollStatus {
  DRAFT      // Created but not open
  OPEN       // Accepting votes
  CLOSED     // Voting ended, results visible
}

// Bridge table: stores signed tokens for eligible users
// This links identity to token temporarily, but the token itself
// is blinded so the server never sees the final voting credential
model PendingSignature {
  id         String @id @default(cuid())
  userId     String
  pollId     String
  blindedSig String // Base64 encoded blind signature

  user User @relation(fields: [userId], references: [id])
  poll Poll @relation(fields: [pollId], references: [id])

  @@unique([userId, pollId]) // One token per user per poll
}

// Anonymous vote tally - no link to user identity
model PollResult {
  pollId   String
  optionId String
  tally    Int    @default(0)

  poll Poll @relation(fields: [pollId], references: [id])

  @@id([pollId, optionId])
}

// Tracks consumed tokens to prevent double voting
// Only stores hash of token, not the token itself
model ConsumedToken {
  tokenHash String   @id
  pollId    String
  consumedAt DateTime @default(now())
}
